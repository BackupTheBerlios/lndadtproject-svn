/**
 * Created on Jun 15, 2008
 */
package unitn.dadtln.samples;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;
import java.util.Vector;

import jist.runtime.JistAPI;
import jist.swans.Constants;
import jist.swans.app.AppJava;
import jist.swans.field.Field;
import jist.swans.field.Mobility;
import jist.swans.field.Placement;
import jist.swans.mac.MacAddress;
import jist.swans.mac.MacDumb;
import jist.swans.misc.Location;
import jist.swans.misc.Mapper;
import jist.swans.misc.Util;
import jist.swans.net.NetAddress;
import jist.swans.net.NetIp;
import jist.swans.net.PacketLoss;
import jist.swans.radio.RadioInfo;
import jist.swans.radio.RadioNoise;
import jist.swans.radio.RadioNoiseIndep;
import jist.swans.trans.TransUdp;

import polimi.ln.examples.swans.SimulationReferences;
import polimi.ln.nodeAttributes.Node;
import polimi.ln.runtime.DatagramObjectIO;
import polimi.ln.runtime.LogicalNeighborhoods;
import polimi.ln.runtime.LogicalNeighborhoodsSwans;
import polimi.ln.runtime.platformDependent.JiSTClock;

/**
 * @author G.Khasanova
 *
 * Package that allows to demonstrate simulation of the DADTLN prototype in JIST/SWANS simulator
 */
public class SimulationSupport {

	private static final int PERIOD = 3000;	// period between client node's requests
	
	// default values for constants, can be set in the command line
	private static int NUM_MESSAGES = 1;	// number of request messages
	private static int NUM_SIM_NODES = 5; 	// number of simulated nodes in WSN
	
	private static ArrayList clientNodeIds = new ArrayList();
	
	/**
	 * Creates a simulated WSN with (args[0]) sensor nodes, and one special ("client") node, that may request data from the simulated WSN.  
	 * Simulation environment is provided by JIST/SWANS network simulator
	 * @param args command line arguments: [0] - number of simulated sensor nodes, [1] number of request messages generated by the client node
	 */
	public static void main(String[] args) {
		
		try {
			
			// code below shows how the simulated network is being initialised 
			try
			{	
				// read command-line arguments, if given, otherwise use default values
				NUM_SIM_NODES = Integer.parseInt(args[0]);
				NUM_MESSAGES = Integer.parseInt(args[1]);
			}
			catch (Exception e){}
			
				System.out.println("Number of sensor nodes in the simulated WSN is " + NUM_SIM_NODES + "\n");
			
			// Defining size of the field where all nodes are to be placed (size depends on the number of nodes, as we try to minimise packet loss)	
			int minDistanceBetweenNodes = 200 + (NUM_SIM_NODES / 20) * 100; 
			int numNodesRow = (int)(Math.sqrt(NUM_SIM_NODES) + 1);
			int maxLength = numNodesRow * minDistanceBetweenNodes;
			
			// Creating the simulation playground of calculated size
			Location.Location2D bounds = new Location.Location2D(maxLength, maxLength);
			Mobility mobility = new Mobility.Static();

			Placement placement = new Placement.Random(bounds); // new Placement.Grid();
			
			// Setting parameters for wireless simulation
			Field field = new Field(bounds);
			field.setMobility(mobility);
			RadioInfo.RadioInfoShared radioInfoShared = RadioInfo.createShared(
					Constants.FREQUENCY_DEFAULT, Constants.BANDWIDTH_DEFAULT,
					Constants.TRANSMIT_DEFAULT, Constants.GAIN_DEFAULT, Util
							.fromDB(Constants.SENSITIVITY_DEFAULT), Util
							.fromDB(Constants.THRESHOLD_DEFAULT),
					Constants.TEMPERATURE_DEFAULT,
					Constants.TEMPERATURE_FACTOR_DEFAULT,
					Constants.AMBIENT_NOISE_DEFAULT);

			// Protocol mapper
			Mapper protMap = new Mapper(Constants.NET_PROTOCOL_MAX);
			protMap.mapToNext(Constants.NET_PROTOCOL_UDP);

			// Packet loss model
			PacketLoss pl = new PacketLoss.Zero();

			// Adding simulated nodes to the defined playground 
			int simNodeId = 0;

			//======= ClientNodes ========
			clientNodeIds.add(simNodeId);
			ClientNode clientNode = new ClientNode();
			createNode(simNodeId, field, radioInfoShared, protMap, pl, pl, 
						new Node(simNodeId, new Vector(), 1, new JiSTClock()), placement, clientNode);
			simNodeId ++;

			/*
			clientNodeIds.add(simNodeId);
			ClientNode clientNode2 = new ClientNode();
			createNode(simNodeId, field, radioInfoShared, protMap, pl, pl, 
						new Node(simNodeId, attributes, 1, new JiSTClock()), 
						placement, clientNode2);
			simNodeId ++;
			*/
			
			//======= SensorNodes ========
			
			for (int i = 0; i < NUM_SIM_NODES; i++)
			{	
				try
				{
					Random rndValue = new Random(System.nanoTime());	// random generator used to create different node configurations
					
					Collection ADTinstances = new ArrayList();			// sensors that are build into sensor node
					
					ADTinstances.add(new Sensor(Sensor.TEMP, rndValue.nextInt(20) * 0.5));		// initialisation of different sensor types
					ADTinstances.add(new Sensor(Sensor.PRESSURE, rndValue.nextInt(20) * 0.5));
					ADTinstances.add(new Sensor(Sensor.HUMIDITY, rndValue.nextInt(20) * 0.5));
					ADTinstances.add(new Sensor(Sensor.LIGHT, rndValue.nextInt(20) * 0.5));
					SensorNode sensorNode = new SensorNode(ADTinstances);						// binding sensors with a sensor node
					
					// creating a simulation sensor node
					createNode(simNodeId, field, radioInfoShared, protMap, pl, pl, 
								new Node(simNodeId, sensorNode.setLNAttributes(), 1, new JiSTClock()), 
								placement, 
								sensorNode);
					simNodeId ++;
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}	
			Thread.sleep(1000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

		
	/**
	 * Sets the simulation parameters for the individual nodes.
	 * 
	 * @param id the node identifier
	 * @param field a reference to the simulation field previously created.
	 * @param radioInfoShared a reference to the radio model previously created.
	 * @param protMap the mappings among network protocols running in the simulation.
	 * @param plIn a reference the the packet loss model for incoming messages.
	 * @param plOut a reference the the packet loss model for outgoing messages.
	 * @param info the logical node associated to the simulated device.
	 * @param posX the physical position of the node along the X axis.
	 * @param posY the physical position of the node along the Y axis.
	 * @throws NoSuchMethodException
	 */
	public static void createNode(int id, Field field,
			RadioInfo.RadioInfoShared radioInfoShared, Mapper protMap,
			PacketLoss plIn, PacketLoss plOut, Node info, Placement placement,
			Object nodeObject)
			throws NoSuchMethodException {

		// Create entities
		RadioNoise radio = new RadioNoiseIndep(id, radioInfoShared);
		MacDumb mac = new MacDumb(new MacAddress(id), radio.getRadioInfo());
		NetAddress netAddr = NetAddress.LOCAL;
		NetIp net = new NetIp(netAddr, protMap, plIn, plOut);
		TransUdp udp = new TransUdp();

		// Hookup entities
		
		
		field.addRadio(radio.getRadioInfo(), radio.getProxy(), placement.getNextLocation());
		field.startMobility(radio.getRadioInfo().getUnique().getID());

		// Radio hookup
		radio.setFieldEntity(field.getProxy());
		radio.setMacEntity(mac.getProxy());

		// Mac hookup
		mac.setRadioEntity(radio.getProxy());
		byte intId = net.addInterface(mac.getProxy());
		mac.setNetEntity(net.getProxy(), intId);

		// Net hookup
		net.setProtocolHandler(Constants.NET_PROTOCOL_UDP, udp.getProxy());

		// Transport hookup
		udp.setNetEntity(net.getProxy());

		SimulationReferences.setNodeInfo(id, info);

		// Starting LN network substrate for UDP
		DatagramObjectIO objectIO = new DatagramObjectIO(
				LogicalNeighborhoods.PORT, LogicalNeighborhoods.BUFFER_SIZE,
				LogicalNeighborhoods.RECEIVE_TIMEOUT);
		SimulationReferences.setObjectIO(id, objectIO);
		AppJava runObjectIO = new AppJava(DatagramObjectIO.class);
		runObjectIO.setUdpEntity(udp.getProxy());
		runObjectIO.getProxy().run(new String[] { String.valueOf(id) });
		JistAPI.sleep(1);

		// Starting Logical Neighborhoods
		LogicalNeighborhoodsSwans ln = new LogicalNeighborhoodsSwans(info,
				objectIO);
		SimulationReferences.setLN(id, ln);
		
		// Starting tick thread to perform periodic maintenance of routes
		AppJava runLNTick = new AppJava(LogicalNeighborhoodsSwans.class);
		runLNTick.setUdpEntity(udp.getProxy());
		runLNTick.getProxy().run(
				new String[] { "tickStart", String.valueOf(id) });
		JistAPI.sleep(1);
		
		// Starting outgoing message queue
		AppJava runLNQueue = new AppJava(LogicalNeighborhoodsSwans.class);
		runLNQueue.setUdpEntity(udp.getProxy());
		runLNQueue.getProxy().run(
				new String[] { "queueStart", String.valueOf(id) });
		JistAPI.sleep(1);

		if (clientNodeIds.contains(id))	{
			// specify ClientNode's parameters , i.e., an AppJava that performs requests of the network
			((ClientNode)nodeObject).setSimNodeInfo(info);
			ln.setReceiver((ClientNode)nodeObject);
			
			AppJava runTestMsg = new AppJava(ClientNode.class);
			runTestMsg.setUdpEntity(udp.getProxy());
			runTestMsg.getProxy().run(
					new String[] { "requestNetwork", String.valueOf(id),
							String.valueOf(NUM_MESSAGES), String.valueOf(PERIOD) });
			JistAPI.sleep(1);
		}
		else 
		{
			// specify SensorNode's parameters
			((SensorNode)nodeObject).setSimNodeInfo(info, ln);	// 
			ln.setReceiver((SensorNode)nodeObject);
		}
	}
	
}
