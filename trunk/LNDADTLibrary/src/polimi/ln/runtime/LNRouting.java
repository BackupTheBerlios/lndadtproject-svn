/***
 * * PROJECT
 * *    Logical Neighborhoods - J2ME Run-Time Support 
 * * VERSION
 * *    $LastChangedRevision: 125 $
 * * DATE
 * *    $LastChangedDate: 2008-06-28 13:07:26 +0100 (Sat, 28 Jun 2008) $
 * * LAST_CHANGE_BY
 * *    $LastChangedBy: lmottola $
 * *
 * *    $Id: LNRouting.java 125 2008-06-28 12:07:26Z lmottola $
 * *
 * *   Logical Neighborhoods - 
 * *                   Programming Wireless Sensor Networks
 * *                   (One Slice at a Time)
 * *
 * *   This program is free software; you can redistribute it and/or
 * *   modify it under the terms of the GNU Lesser General Public License
 * *   as published by the Free Software Foundation; either version 2.1
 * *   of the License, or (at your option) any later version.
 * *
 * *   This program is distributed in the hope that it will be useful,
 * *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 * *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * *   GNU General Public License for more details.
 * *
 * *   You should have received a copy of the GNU Lesser General Public 
 * *   License along with this program; if not, you may find a copy at 
 * *   the FSF web site at 'www.gnu.org' or 'www.fsf.org', or you may 
 * *   write to the Free Software Foundation, Inc., 59 Temple 
 * *   Place - Suite 330, Boston, MA  02111-1307, USA
 ***/

package polimi.ln.runtime;

import java.util.HashMap;
import java.util.Vector;

import polimi.ln.neighborhoodDefs.Neighborhood;
import polimi.ln.nodeAttributes.Node;
import polimi.ln.runtime.messages.AppMsg;
import polimi.ln.runtime.messages.LNMessage;
import polimi.ln.runtime.messages.ReplyMsg;

/**
 * @author Luca Mottola <a
 *         href="mailto:mottola@elet.polimi.it">mottola@elet.polimi.it</a>
 * 
 */
public class LNRouting {

	private NeighborSet neighborSet;

	private HashMap seenMessages;

	private LogicalNeighborhoods ln;

	private Node nodeInfo;

	private byte disseminationFanOut;

	private long appTime;

	public LNRouting(Node info, NeighborSet neighborSet,
			byte disseminationFanOut, LogicalNeighborhoods ln) {

		this.disseminationFanOut = disseminationFanOut;
		this.ln = ln;
		this.nodeInfo = info;
		this.neighborSet = neighborSet;
		this.seenMessages = new HashMap();
		this.appTime = 0;
	}

	protected void generateAppMsg(Object data, Neighborhood[] scopes) {
		AppMsg msg;

		// TODO: Derive overlapping scopes
		for (int i = 0; i < scopes.length; i++) {
			if (scopes[i].hasMaxHops()) {
				msg = new AppMsg(nodeInfo.getMyId(), appTime++, data,
						scopes[i], scopes[i].getMaxHops());
			} else {
				msg = new AppMsg(nodeInfo.getMyId(), appTime++, data, scopes[i]);
			}
			ln.sendMessage(msg);
		}
	}

	protected void generateReplyMsg(Object data, int destination) {

		ln.sendMessage(new ReplyMsg(nodeInfo.getMyId(), appTime++, data,
				destination));
	}

	protected void parseAppMsg(AppMsg msg) {

		if (!isAlreadySeen(msg)) {
			if (msg.getLNScope().matches(nodeInfo)) {
				
				nodeInfo.debugPrint("Got AppMsg from "
						+ msg.getSenderId() + " [generated by "
						+ msg.getOriginatorId() + "]");
				
				ln.deliver(msg.getData());
			}
			if (!msg.isMaxHops() || msg.getHops() < msg.getMaxHops()) {
				
				nodeInfo.debugPrint("Forwarding message from "
						+ msg.getSenderId() + " [generated by "
						+ msg.getOriginatorId() + "]");
						
				Vector destinations = new Vector(neighborSet
						.returnRandomNeighbors(disseminationFanOut));
				msg.setDestinations(destinations);
				ln.forwardMessage(msg);
			}
		}
	}

	protected void parseReplyMsg(ReplyMsg msg) {

		if (!isAlreadySeen(msg)) {
			if (msg.getDestination() == nodeInfo.getMyId()) {
				ln.deliver(msg.getData());
			}
			/*
			nodeInfo.debugPrint("Forwarding reply message from "
					+ msg.getSenderId() + " generated from "
					+ msg.getOriginatorId());
			*/		
			Vector destinations = new Vector(neighborSet
					.returnRandomNeighbors(disseminationFanOut));
			msg.setDestinations(destinations);
			ln.forwardMessage(msg);
		}
	}

	private boolean isAlreadySeen(LNMessage msg) {

		// TODO: Implement limited buffer
		Vector seenForId = (Vector) seenMessages.get(new Integer(msg
				.getOriginatorId()));

		if (seenForId == null) {
			// Never got a message from this node
			seenForId = new Vector();
			seenForId.add(new Long(msg.getSeqNumber()));
			seenMessages.put(new Integer(msg.getOriginatorId()), seenForId);
			return false;
		} else {
			if (!seenForId.contains(new Long(msg.getSeqNumber()))) {
				seenForId.add(new Long(msg.getSeqNumber()));
				return false;
			} else {
				return true;
			}
		}
	}
}
