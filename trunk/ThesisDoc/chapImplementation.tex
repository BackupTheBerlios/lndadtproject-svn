\chapter{Distributed Programming Abstractions for WSNs}
\label{chap:Implementation}

%intro words

\textcolor{green}{re-write! probably the sequence is outdated}

This chapter begins with implementation details underlying Distributed Abstract
Data Types (DADTs), a short description of existing DADT prototype
\cite{migliavacca_DADT:2006}, and an outline of the limitations of the current
prototype. The chapter then provides information about author's contribution and
discusses architecture of implemented DADT/LN prototype. This is followed by the
implementation details the DADT/LN prototype which allowed use of DADT concepts
in the real-world WSNs. This is folowed by a presentation of the simulation
environment, simulating tools that were used for verification of the
implementation. This chapter further presents the evaluation results for the
DADT/LN prototype run on the Sun SPOTs. The chapter concludes with discussion
of possible extensions of the prototype.

\section {The DADT Prototype}

Use of DADTs can be applied to the context-aware distributed applications, as
it was discussed in the Section \ref{sec:DADT}. This section provides reader with
further details of DADT concepts, a presentation of the existing DADT
prototype \cite{migliavacca_DADT:2006} and discusses its limitations.

\subsection{ADTs Specification and Instantiation} \label{subsec:ADTSpecInst}

As it was mentioned in the Section \ref{subsubsec:ADTsinWSN}, each sensor node
in WSNs can be abstracted though a multiple number of ADT instances (see
Figure \ref{Fig:MultipleADTs}) and therefore conceal the details of sensor
node's abstraction from the application developer. Code snippets below are
provided to illustrate concepts in further detail.

The specification for described ADTs\footnote{According to classification of
ADTs this is an example of the Data ADT (see Section
\ref{subsubsec:DataAndSpaceADTs})} could be defined as Java interface as presented in the Listing \ref{listing:ADTSpec}

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b,
basicstyle=\ttfamily\footnotesize, breaklines, caption = Sensor ADT instances, label =
listing:ADTSpec]
class Sensor {
  //data properties of the sensor 
    int sensorType;
    double sensorReading;
    boolean active; 
  //operations that can be performed on the sensor  
    public double read(){ //read the sensor value.
	  ...
	} 
	public void reset(){ //reset the sensor
	  ...
	}    
\end{lstlisting}

This specification declares that a Sensor ADT instance should provide the following properties:
\begin{itemize}
\item an integer value to define the sensor type,
\item a double value that holds the sensor data, 
\item a boolean value that stores information about sensor's state of activity
\end{itemize}
and the operations that allow to \emph{Read} sensor data and to \emph{Reset}
sensor.

It is possible to define multiple such instances of this
specification, for example, the ADT instances for a given sensor node that has two kinds of sensors - (a) a
temperature sensor and (b) a light sensor - may be defined using the ADT
specification described above as shown in the Listing
\ref{listing:ADTInstances}. 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b,
basicstyle=\ttfamily\footnotesize, breaklines, caption = Sensor ADT instances, label =
listing:ADTInstances]
  // Temperature sensor ADT instance
  Sensor temperatureSensor = new Sensor(TEMPERATURE);
  ...
  // Humidity sensor ADT instance  
  Sensor lightSensor = new Sensor(LIGHT);
\end{lstlisting}

\subsection{DADT Specification and Instantiation} \label{subsubsec:dadtspecandinst}

The concept of DADTs was first introduced in the Section \ref{sec:DADT} and will
be extended with examples of DADT specifications and instances in this chapter.
 
DADT specifications can be best understood by carrying forward the example
described in Section \ref{subsec:ADTSpecInst}. To allow for collective access
to multiple ADT instances of the type specified in Listing
\ref{listing:ADTSpec}, a DADT \emph{DSensor} may be defined as shown in Listing
\ref{listing:DADTSpec}.   
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Data DADT 
specification (reproduced from \cite{migliavacca_DADT:2006}), label = 
listing:DADTSpec]
class DSensor{
  // type of ADTs
    Class distributes = Sensor.class;	
  // distributed operations:
	void resetAll();
	double average();
}
\end{lstlisting} 
 
The DADT specification allows two simple distributed operations to be performed
on multiple data ADTs of type \emph{Sensor}:  
\begin{itemize}
\item \emph{resetAll()} that is used to reset every sensor in the DADT member
set, or subset of ADT instances defined by a DADT View (see Section
\ref{subsubsec:views}).
\item \emph{average()} that allows to calculate the average of readings of every
sensor in the member set or subset defined by DADT view.
\end{itemize}

Listing \ref{listing:DADTInstance} shows how DADT specifications can be
instantiated as an object of a Java class, and be used to perform defined
distributed operations.

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = DADT Instantiation 
(adapted from \cite{migliavacca_DADT:2006}), label = listing:DADTInstance ]
DSensor ds = new DSensor();
ds.resetAll();
\end{lstlisting}

\subsubsection{Binding}

As it was specified in the Section \ref{subsec:DADTsConcepts}, a DADT member set
 is being built by the set of ADTs that are available for collective
access, in the given example, the collection of ADTs of type \emph{Sensor}.

An ADT instance is made part of the member set by binding it to the DADT type.
This can be done using a dedicated programming construct as shown in Listing
\ref{listing:binding}, where the Sensor ADT (see Listing \ref{listing:ADTSpec}) is bound to the DADT type \emph{DSensor}
defined in Listing \ref{listing:DADTSpec}.
 
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Binding ADT instances to a DADT instance, label = listing:binding]
bind(new Sensor(TEMPERATURE), "DSensor");
...
bind(new Sensor(LIGHT), "DSensor");
\end{lstlisting} 


\subsubsection{DADT Operators and Actions}
\label{subsubsec:OperatorsAndActionsImpl}

The Section \ref{subsubsec:OperatorsAndActions} has introduced the
concept of DADT Operators and DADT Actions. 

Use of DADT selection operator \emph{all} can be explained through the
extended example of DADT Specification (see Listing \ref{listing:DADTSpec]})
which uses pseudolanguage. This code snippet is shown in the
Listing \ref{listing:DADTOperator}.

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Defining a DADT action, label = listing:DADTOperator]  
class DSensor {
  ...
  public void resetAll(){
	 (all in targetset).reset();
  }
}
\end{lstlisting}

Distributed operation \emph{resetAll} uses selection operator 
\emph{all} for obtaining an access to all ADT instances of the DADT
target set, and subsequently invokes aperation \emph{reset} on the ADT
instance, which was defined in the ADT specification (see Listing
\ref{listing:ADTSpec}).

\textcolor{red}{rewrite here }

To perform a DADT \emph{Read} operation, an action is defined
as shown in Listing
\ref{listing:DADTAction}. 
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Defining a DADT action, label = listing:DADTAction ]  
public class DSensor_read_Action implements DADT.Action{

  public Object evaluate(Object ADTInstance){
	Sensor localSensor = (Sensor) ADTInstance;
    return localSensor.read();
  }
}
\end{lstlisting}

This results in the operation {Read} to be invoked on the given sADT
instance of type \emph{Sensor} (see Listing \ref{listing:ADTSpec}).

When the application programmer attempts to execute a DADT operation, such as
for instance, the computation of the average
across all sensors in its target set (see Listing \ref{listing:DADTInstance}),
actions of the sort defined above are called. 

\subsubsection{DADT Views} \label{subsubsec:viewsImpl}

Concept of DADT Views is an effective tool for the application developer to
define scope of the distributed operation. As it was described in the Section
\ref{subsubsec:views}, this concept is based on the definition of DADT
properties.

To continue on the example running throughout this section, if the application
programmer has to partition the subset of ADT instances among those bound to the
DADT type \emph{DSensor} (See Listing \ref{listing:binding}), and refer to it
as a subset of temperature sensors, a data view \emph{TempSensors}, 
as shown in the Listing \ref{listing:views}, can be delared.
  
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Definition of DADT Data View, label = listing:views ]  
dataview TempSensors on DSensor as isSensorType(TEMPERATURE) && isActive(); 
\end{lstlisting}

The DADT name \emph{DSensor} in this case refers to its member set, and 
the data view \emph{temperature} is defined as a subset of this member set and
contains only sensor nodes with temperature sensors for which evaluation of
the property \emph{isActive} returns \emph{true}. The data view definitions are
used to restrict  the scope of the DADT operations.

\subsection{Limitations of the DADT Prototype}

The DADT prototype, proposed in \cite{migliavacca_DADT:2006}, enables the use of
DADTs to facilitate distributed application programming.

It supports is a Java-based application development and consists of two parts:
\begin{itemize}
  \item \emph{Translator}, that proviides translation of Java program
  extended with DADT programming constructs into conventional Java classes.
  \item \emph{Run-time library} is used at translation step and allows to run
  created Java classes in  JVM.
\end{itemize}

Run-time library provides support for DADT constructions and methods, such as
\emph{binding} ADTs to DADTs, \emph{DADT Views}, \emph{Actions} and
\emph{Operators}. 

The communication in the prototype is based on the IP Multicast principle, and
allows to deliver information to the ADTs bound to a specific DADT, defined as
a multicast group.

The DADT prototype has presented a proof of the DADT concept. While this
approach is clearly applicable to WSNs, the prototype itself did not support WSN
abstractions, and besides has major limitations to it:

\begin{itemize}
  \item The lack of a routing mechanism.
  \item Limitations in portability to real WSN nodes.
\end{itemize}

\section{The DADT/LN Prototype}

\subsection{Motivation}

As mentioned in the previous section, the DADT prototype
\cite{migliavacca_DADT:2006} showed that DADT approach theoretically can be used
for distributed WSN applications, but existing limitations prevent its use in WSN
simulators or real nodes.

This work makes the following contributions:

\begin{itemize}
  \item Enhance the DADT prototype for use in WSNs by extending it to run
  on simulators as well as devices in a real-world environment.
  \item Interfacing the LN mechanism presented in \cite{mottola_LNAbstraction}
  to enable abstracted communication between groups of nodes in the WSN defined
  by DADTs.
  \item  Verification of the utility of DADT abstractions in the WSN application
  layer.
\end{itemize}

\subsection{Architecture}

% FILL THIS IN LATER.


\subsection{Overview}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/DADTLN_architecture.eps} 
\caption[DADT/LN application workflow]{Workflow for development of an application that uses
the DADT/LN prototype}
\label{Fig:DADTLN_architecture}
\end{figure} 
The overview of the workflow involved in using DADTs to enable WSN application
programming is as shown in Figure \ref{Fig:DADTLN_architecture}. The user writes
application layer code for the WSN using a DADT language in a series of
\emph{.dadt} files. A preprocessor is used to convert the code written by the
application programmer into Java code that interfaces with the DADT
infrastructure (extended from the prototype presented in
\cite{migliavacca_DADT:2006}). In order to facilitate routing to LNs defined by
the use of DADT views, the DADT infrastructure is interfaced with the a
previously developed implementation of LNs. 

The application (including the implementation of layers lower in the protocol
stack) is then loaded on to either:
\begin{itemize}
\item the JiST/SWANS simulator \cite{barr_JIST:2005, barr_SWANS}. See Section \ref{sec:jistswans} for details on the implementation of
the aforementioned simulator
\item a collection of Sun SPOT wireless sensor devices \cite{simon_squawk:2006}
(see Section \ref{sec:sunspots}) to execute the application on real sensor nodes.
\end{itemize}

\subsubsection{Explanation of terms used}

\begin{figure}
\centering
\includegraphics[scale=0.55]{img/DADTLN_glossary.eps} 
\caption[WSN in DADT/LN prototype]{Schematic Representation of the WSN as abstracted in the DADT/LN prototype}
\label{Fig:DADTLN_glossary}
\end{figure} 

This section explains the terms used in the DADT/LN prototype developed as part
of this work. The WSN network in this prototype consists of two types of
devices as shown in Figure \ref{Fig:DADTLN_glossary}: 
\begin{itemize}
  \item \emph{Controller:} Typically PC-based, this node contains in the
  application layer the client node, the expression tree, the DADT instance, the
  DADT manager; the LN
  implementation is used in the network layer. The user's application code resides on
  the controller node.
  \item \emph{Sensor Device:} This is a sensor device such as a Sun SPOT, and
  holds the following entities:
  \begin{itemize}
    \item \emph{Application Layer:} It includes a Sensor Node that in turn
    consists of multiple sensor ADT instances, and an ADT manager.
    \item \emph{Network Layer:} The LN implementation is used.
  \end{itemize}
\end{itemize}

\subsection{Implementation Details}

This section attempts to explain the operation of the DADT/LN prototype
developed as part of this work by considering the sequence of method calls made
during execution. The operation of the simulation platform as well as the
nodes itself is abstracted from the explanations that follow, as is the actual
\emph{.dadt} syntax used by the application programmer himself to trigger these
operations. 

\subsubsection{The DADT/LN prototype on the Controller}

Figure \ref{Fig:SeqDiagram_Sensornode} presents the operation of the DADT/LN
prototype on the controller (which is typically PC-based). As shown in the figure, the implementation running on each sensor node 
consists of the following entities:

\begin{itemize}
  \item \emph{Client Node:} A Client Node is an abstraction that consists of a
  DADT instance. The application programmer's requests to the network are issued
  by the Client Node.
  \item \emph{DADT Instance:} A DADT Instance is explained in Section
  \ref{subsubsec:dadtspecandinst}, and allows for collective access to multiple
  ADT instances.
  \item \emph{Expression Tree:} An expression tree is a specific construct that is to
  build a hierarchical data view.
  \item \emph{DADT Manager:} The DADT Manager provides the interface between the
  Client Node and the network, and passes request messages from the Client Node
  to the lower layers of the protocol stack.
  \item \emph{Data View:} Data views are explained in Section
  \ref{subsubsec:views}, and is a mechanism for partitioning the collection of
  ADT instances bound to a particular DADT type.
\end{itemize}

The instantiation of a DADT type by the application programmer's
code\footnote{This is written in the DADT specification language.} causes the
following actions to take place at the Controller:
\begin{itemize}
  \item The Client Node creates an instance of the DADT type that is used to perform
collective operations on the network.  
\item A new expression tree is created to provide a hierarchical representation
of the application programmer's definition of a data view.
\item The DADT instance creates an instance of the DADT manager.
\end{itemize}

When the application programmer's code requests the execution of a distributed operation
on the WSN, the following actions take place:

\begin{itemize}
  \item The Client Node forwards the request to the DADT instance. The DADT instance:
  \begin{itemize} 
    \item creates a Data
  view using the expression tree (see above),
  \item subsequently uses the DADT 
  manager to construct LN predicates from the expression, 
  \item sends a
  request message to the network using the DADT manager, and
  \item sleeps until the result of the computation is
  received from the network layer \emph{(N.B.: The DADT instance is implemented as a
  separate thread)}.
  \end{itemize}
  \item When the result of the distributed computation is received, the Client Node is notified. 
 The Client Node then executes
  the appropriate function on the DADT instance to collect and process the
  readings. The DADT instance returns the processed readings to the Client Node.
\end{itemize}


\subsubsection{The DADT/LN prototype on the sensor device} \label{subsubsec:DADTLNSensorDevice}

Figure \ref{Fig:SeqDiagram_Sensornode} presents the operation of the DADT/LN
prototype on the sensor device (which may be either simulated or a real
device). As shown in the figure, the implementation running on each sensor node 
consists of the following entities:

\begin{itemize}
  \item \emph{Sensor Node:} A sensor node is an abstraction that consists of a
  list of sensors. This follows from the example used to illustrate the concept
  of ADTs in Section \ref{sec:DADT}\footnote{The term \emph{device} is used to
  refer to the physical sensor node entity, while the term \emph{sensor node}
  refers to the application layer abstraction of all of the sensors within the
  device. This abstraction resides on the device.}
  \item \emph{Sensor ADT instance:} This is an ADT instance for a given sensor
  on the sensor node upon which the prototype executes. 
  \item \emph{ADT Manager:} The ADT manager provides the interface between the
  sensor node and the network, thereby abstracting sensor ADT instances from
  queries issued by the DADT instance at the (PC-based) controller.
\end{itemize}

Sensor ADT instance intialisation is performed possibly
multiple times
on a given Sensor Node, as a node might consist of multiple sesnsors. Following
this, the sensor ADT instances are bound to a particular DADT type by calling
the ADT manager\footnote{The ADT manager is assumed in our
current implementation to be aware of all DADT types defined in the WSN.}.

When the lower layer (which runs the LN algorithm) delivers a message to the
Sensor Node, the ADT Manager is used to processed the request message.The
request message contains a DADT Data view (see Section \ref{subsubsec:views})
which is used to filter from the sensor ADT instances on the given Sensor node
those that fit into the Data view. % DOUBLE PROCESSING. YOU KNOW. I SUGGEST GET% RID OF IT.

\emph{N.B.: If the request message is received in the application layer, then at least
one of the sensor ADT instances in the Sensor Node fits into the dataview, as
the data view is expressed in the form of an LN predicate. This minimises the
number of messages received at the application layer. However, since a given
Sensor Node may contain several sensor ADT instances, the ADT instances have to
be filtered.}

The request message also contains a description of the DADT action to be
performed on-device (see Section
\ref{subsubsec:OperatorsAndActions}). The ADT manager calls the action for each
sensor ADT instance that fits into the DADT Data view. 

If the application layer requires that a reply be sent, the LN implementation in
the lower layer of the protocol stack is used as it can be seen on the bottom
right section of Figure \ref{Fig:SeqDiagram_Sensornode}.

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{img/SeqDiagram_PCnode.eps}
\caption[Operation of the DADT/LN prototype on Controller]{Operation of the DADT/LN prototype on Controller}
\label{Fig:SeqDiagram_PCnode}
\end{sidewaysfigure}


\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{img/SeqDiagram_Sensornode.eps}
\caption[Operation of the DADT/LN prototype on sensor device]{Operation of the DADT/LN prototype on sensor device}
\label{Fig:SeqDiagram_PCnode}
\end{sidewaysfigure}

\subsection{The DADT/LN prototype in the simulated environment}
\subsubsection {JiST/SWANS} \label{sec:jistswans}

As the simulator used in this work is a discrete event simulator, this section 
begins with a short description of discrete event simulators. 
This is followed by a discussion on a particular discrete event simulator
called JiST, and the SWANS network simulator built on top of JiST.

\paragraph{Discrete Event Simulator}

A discrete event simulator allows for the simulated execution of a process (that
may be either deterministic or stochastic), and consists of the following
components \cite{Shankar_DiscreteEventSim}:

\begin{itemize}
  \item \emph{Simulation variables:} These variables keep track of simulation 
  time, the list of events to be simulated, the (evolving) system state, and 
  performance indicators.
  \item \emph{Event handler:} The event handler schedules events for execution 
  at specific points in simulation time (and unschedules them if necessary), 
  and additionally updates the state variables and performance indicators.
\end{itemize}
 
\paragraph{Java In Simulation Time (JiST)} \label{subsec:jist}

JiST \cite{barr_JIST:2005} is a discrete event simulator that is 
efficient (compared to existing simulation systems), 
transparent (simulations are automatically translated to run with the 
simulation time semantics), and standard (simulations use a
conventional programming language, i.e., Java).

JiST simulation code is written in Java, and converted to run over the JiST 
simulation kernel using a bytecode-level rewriter\footnote{N.B.: The bytecode 
rewriter and the simulation kernel are both written in Java},  as it can be
seen in Figure \ref{Fig:JiST_architecture}.

The execution of a JiST program can be understood by considering example as
shown in Listing \ref{listing:JiSTExample}

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Example JiST program (reproduced from \cite{barr_JIST:2005}, label = listing:JiSTExample]  
import jist.runtime.JistAPI;  
class hello implements JistAPI.Entity { 
  public static void main(String[] args) { 
    System.out.println("Simulation start"); 
    hello h = new hello(); 
    h.myEvent(); 
  } 
  public void myEvent() { 
    JistAPI.sleep(1); 
    myEvent(); 
    System.out.println("hello world, " + JistAPI.getTime()); 
  }} 
\end{lstlisting}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/JiST_architecture.eps} 
\caption[The JiST System Architecture]{The JiST system architecture (reproduced from
\cite{barr_JIST:2005})}
\label{Fig:JiST_architecture}
\end{figure}  
 
This program is then compiled and executed in the JiST simulation
kernel, using the following commands:

  
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Execution of the
program in the JiST, label = listing:JiST ]  
javac hello.java
java jist.runtime.Main hello
\end{lstlisting}


The simulation kernel is loaded upon execution of this command. This kernel
installs into the JVM a class loader that performs the rewrite of the bytecode.
The JistAPI functions used in the example code are used to perform the
code transformations. The method call to myEvent is now scheduled and executed
by the simulator in simulation time. Simulation time differs from ``actual''
time in that the advancement of actual time is independent of application
execution. 
 
\paragraph{Scalable Wireless Ad hoc Network Simulator (SWANS)}
SWANS is a wireless network simulator developed in order to provide efficient
and scalable simulations without compromising on simulation detail \cite{barr_SWANS},
and is built upon the JiST discrete event simulator described in Section \ref{subsec:jist}. 
It is organised a a collection of independent, relatively simple, event driven
components that are encapsulated as JiST entities. 
  
SWANS has the following capabilities \cite{barr_SWANS}:

\begin{itemize}
\item The use of
interchangeable components enables the construction of a protocol stack for the
network, and facilitates parallelism, and execution in a distributed environment.
\item Can execute unmodified Java network applications on the
simulated network (in simulation time), by virtue of its being built over
JiST.Using a harness, the aforementioned Java code is automatically rewritten to
run on the simulated network.  
\end{itemize}
   
The SWANS architecture may be seen in Figure \ref{Fig:SWANS_architecture}. 

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{img/SWANS_architecture.eps} 
\caption[SWANS architecture]{SWANS architecture}
\label{Fig:SWANS_architecture}
\end{figure} 

\subsubsection{Simulation using JiST/SWANS}

The DADT/LN prototype was tested on the SWANS WSN simulator, that is buit upon
the JiST discrete event simulator (see Section \ref{subsec:jist}). 

The DADT/LN prototype code is wrapped in the JiST API, and is loaded on to a
simulated node. As described in the previous section, there are two kinds of
nodes in the DADT/LN prototype:

\begin{itemize}
  \item \emph{Controller Node}, that holds the distributed application, and the
  framework to manage the same.
  \item \emph{Sensor Device}, that holds the individual ADT instances. 
\end{itemize}

The Controller Node was implemented as a separate node on the JiST/SWANS
simulator, and was assumed not to be PC-based for the purposes of simulation.
The Sensor Device implementation (see Section
\ref{subsubsec:DADTLNSensorDevice}) was loaded on to all but one of the nodes in
the simulator.

The simulation was run on networks of upto 50 nodes to empirically verify the
robustness of the work done as part of this thesis.

\subsection{The DADT/LN prototype on Sun SPOTs}

For further experimental validation of the implementation produced as part of 
this thesis,
the DADT/LN prototype was deployed on Sun SPOTs \cite{simon_squawk:2006}. 

The
Controller application was executed as a host application on the host machine (a
PC), while the other Sun SPOTs ran the Sensor Device implementation as on-SPOT
applications (see Section \ref{subsec:sunspotapps} for a description of host and on-SPOT
applications).



\section{Evaluation}

The performance of the DADT/LN prototype was evaluated using the following
metrics: 
\begin{itemize}
  \item Packet processing workload on the application layer.
  \item Ease of implementation. 
\end{itemize}

The first metric was used to compare the performance of the DADT/LN prototype
against that of the original DADT prototype used as the basis for this work
\cite{migliavacca_DADT:2006}. In the original DADT prototype, a request message
was replied to or discarded on the basis of an expression tree evaluation in the
application layer. In the implementation presented in this work, the integration
with the LN approach results in unsuitable request messages being discarded on
the basis of predicate evaluation in the network layer. 


A series of simulations were run using the JiST/SWANS simulations to determine
the number of request messages discarded at the network layer and the number
passed on to the application layer by the LN predicate matching algorithm. The
sum provides the total number of packets processed in the application layer of
the original DADT prototype.

It was found that the number of messages processed in the application layer was
lower in the implementation produced as part of this work.

%HOW CAN WE SAY LN PREDICATE EVAL IS MORE EFFICIENT THAN EXPRESSION TREE?

The second metric used the number of lines of code required to implement a
simple distributed averaging application. While not an ideal metric, it
quantifies the difference in the order of magnitude of coding effort required on
the part of the application programmer to produce WSN applications with and
without the use of programming abstractions. To this end, a simple WSN
application was written on the Sun SPOTs to calculate the distributed average.

The difference in the number of lines was **.

\section{Future Work}

This section presents a list of possible extensions to the work implemented as
part of this thesis. These include:

\begin{itemize}
  \item \emph{Support for DADT selection operators:} The current prototype
  supports the selection of all ADT instances that match a defined DADT Data
  view, but does not enable the selection of a subset of the aforementioned
  collection of ADT instances. This arises due to limitations in the current LN implementation.
  \item \emph{Extending support for Space DADTs:} Currently, the prototype does
  not use the notion of space. Therefore, a possible avenue for future work
  could include the implementation of Space DADTs, and the definition of Space
  views that are analogous to Data views.
  \item \emph{Extending the prototype for networks of heterogenous nodes:}
  The current prototype, by virtue of it being implemented in Java, cannot be
  used on a wide variety of different nodes. 
\end{itemize}

\section{Conclusions}

%HERE MORE BLAH BLAH