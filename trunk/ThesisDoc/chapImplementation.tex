\chapter{Distributed Programming Abstractions for WSNs}
\label{chap:Implementation}

%intro words

\textcolor{green}{re-write! probably the sequence is outdated}

This chapter begins with implementation details underlying Distributed Abstract
Data Types (DADTs), a short description of existing DADT prototype
\cite{migliavacca_DADT:2006}, and an outline of the limitations of the current
prototype. The chapter then provides information about author's contribution and
discusses architecture of implemented DADT/LN prototype. This is followed by the
implementation details the DADT/LN prototype which allowed use of DADT concepts
in the real-world WSNs. This is folowed by a presentation of the simulation
environment, simulating tools that were used for verification of the
implementation. This chapter further presents the evaluation results for the
DADT/LN prototype run on the Sun SPOTs. The chapter concludes with discussion
of possible extensions of the prototype.

\section {The DADT Prototype}

Use of DADTs can be applied to the context-aware distributed applications, as
it was discussed in the Section \ref{sec:DADT}. This section provides reader with
further details of DADT concepts, a presentation of the existing DADT
prototype \cite{migliavacca_DADT:2006} and discusses its limitations.

\subsection{ADTs Specification and Instantiation} \label{subsec:ADTSpecInst}

As it was mentioned in the Section \ref{subsubsec:ADTsinWSN}, each sensor node
in WSNs can be abstracted though a multiple number of ADT instances (see
Figure \ref{Fig:MultipleADTs}) and therefore conceal the details of sensor
node's abstraction from the application developer. Code snippets below are
provided to illustrate concepts in further detail.

The specification for described ADTs\footnote{According to classification of
ADTs this is an example of the Data ADT (see Section
\ref{subsubsec:DataAndSpaceADTs})} could be defined as Java interface as presented in the Listing \ref{listing:ADTSpec}

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b,
basicstyle=\ttfamily\footnotesize, breaklines, caption = Sensor ADT instances, label =
listing:ADTSpec]
class Sensor {
  //data properties of the sensor 
    int sensorType;
    double sensorReading;
    boolean active; 
  //operations that can be performed on the sensor  
    public double read(){ //read the sensor value.
	  ...
	} 
	public void reset(){ //reset the sensor
	  ...
	}    
\end{lstlisting}

This specification declares that a Sensor ADT instance should provide the following properties:
\begin{itemize}
\item an integer value to define the sensor type,
\item a double value that holds the sensor data, 
\item a boolean value that stores information about sensor's state of activity
\end{itemize}
and the operations that allow to \emph{Read} sensor data and to \emph{Reset}
sensor.

It is possible to define multiple such instances of this
specification, for example, the ADT instances for a given sensor node that has two kinds of sensors - (a) a
temperature sensor and (b) a light sensor - may be defined using the ADT
specification described above as shown in the Listing
\ref{listing:ADTInstances}. 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b,
basicstyle=\ttfamily\footnotesize, breaklines, caption = Sensor ADT instances, label =
listing:ADTInstances]
  // Temperature sensor ADT instance
  Sensor temperatureSensor = new Sensor(TEMPERATURE);
  ...
  // Humidity sensor ADT instance  
  Sensor lightSensor = new Sensor(LIGHT);
\end{lstlisting}

\subsection{DADT Specification and Instantiation} \label{subsubsec:dadtspecandinst}

The concept of DADTs was first introduced in the Section \ref{sec:DADT} and will
be extended with examples of DADT specifications and instances in this chapter.
 
DADT specifications can be best understood by carrying forward the example
described in Section \ref{subsec:ADTSpecInst}. To allow for collective access
to multiple ADT instances of the type specified in Listing
\ref{listing:ADTSpec}, a DADT \emph{DSensor} may be defined as shown in Listing
\ref{listing:DADTSpec}.   
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Data DADT 
specification (reproduced from \cite{migliavacca_DADT:2006}), label = 
listing:DADTSpec]
class DSensor{
  // type of ADTs
    Class distributes = Sensor.class;	
  // distributed operations:
	void resetAll();
	double average();
}
\end{lstlisting} 
 
The DADT specification allows two simple distributed operations to be performed
on multiple data ADTs of type \emph{Sensor}:  
\begin{itemize}
\item \emph{resetAll()} that is used to reset every sensor in the DADT member
set, or subset of ADT instances defined by a DADT View (see Section
\ref{subsubsec:views}).
\item \emph{average()} that allows to calculate the average of readings of every
sensor in the member set or subset defined by DADT view.
\end{itemize}

Listing \ref{listing:DADTInstance} shows how DADT specifications can be
instantiated as an object of a Java class, and be used to perform defined
distributed operations.

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = DADT Instantiation 
(adapted from \cite{migliavacca_DADT:2006}), label = listing:DADTInstance ]
DSensor ds = new DSensor();
ds.resetAll();
\end{lstlisting}

\subsubsection{Binding}

As it was specified in the Section \ref{subsec:DADTsConcepts}, a DADT member set
 is being built by the set of ADTs that are available for collective
access, in the given example, the collection of ADTs of type \emph{Sensor}.

An ADT instance is made part of the member set by binding it to the DADT type.
This can be done using a dedicated programming construct as shown in Listing
\ref{listing:binding}, where the Sensor ADT (see Listing \ref{listing:ADTSpec}) is bound to the DADT type \emph{DSensor}
defined in Listing \ref{listing:DADTSpec}.
 
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Binding ADT instances to a DADT instance, label = listing:binding]
bind(new Sensor(TEMPERATURE), "DSensor");
...
bind(new Sensor(LIGHT), "DSensor");
\end{lstlisting} 


\subsubsection{DADT Operators and Actions}
\label{subsubsec:OperatorsAndActionsImpl}

The Section \ref{subsubsec:OperatorsAndActions} has introduced the
concept of DADT Operators and DADT Actions. 

Use of DADT selection operator \emph{all} can be explained through the
extended example of DADT Specification (see Listing \ref{listing:DADTSpec]})
which uses pseudolanguage. This code snippet is shown in the
Listing \ref{listing:DADTOperator}.

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Defining a DADT action, label = listing:DADTOperator]  
class DSensor {
  ...
  public void resetAll(){
	 (all in targetset).reset();
  }
}
\end{lstlisting}

Distributed operation \emph{resetAll} uses selection operator 
\emph{all} for obtaining an access to all ADT instances of the DADT
target set, and subsequently invokes aperation \emph{reset} on the ADT
instance, which was defined in the ADT specification (see Listing
\ref{listing:ADTSpec}).

\textcolor{red}{rewrite here }

To perform a DADT \emph{Read} operation, an action is defined
as shown in Listing
\ref{listing:DADTAction}. 
 
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Defining a DADT action, label = listing:DADTAction ]  
public class DSensor_read_Action implements DADT.Action{

  public Object evaluate(Object ADTInstance){
	Sensor localSensor = (Sensor) ADTInstance;
    return localSensor.read();
  }
}
\end{lstlisting}

This results in the operation {Read} to be invoked on the given sADT
instance of type \emph{Sensor} (see Listing \ref{listing:ADTSpec}).

When the application programmer attempts to execute a DADT operation, such as
for instance, the computation of the average
across all sensors in its target set (see Listing \ref{listing:DADTInstance}),
actions of the sort defined above are called. 

\subsubsection{DADT Views} \label{subsubsec:viewsImpl}

Concept of DADT Views is an effective tool for the application developer to
define scope of the distributed operation. As it was described in the Section
\ref{subsubsec:views}, this concept is based on the definition of DADT
properties.

To continue on the example running throughout this section, if the application
programmer has to partition the subset of ADT instances among those bound to the
DADT type \emph{DSensor} (See Listing \ref{listing:binding}), and refer to it
as a subset of temperature sensors, a data view \emph{TempSensors}, 
as shown in the Listing \ref{listing:views}, can be delared.
  
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Definition of DADT Data View, label = listing:views ]  
dataview TempSensors on DSensor as isSensorType(TEMPERATURE) && isActive(); 
\end{lstlisting}

The DADT name \emph{DSensor} in this case refers to its member set, and 
the data view \emph{temperature} is defined as a subset of this member set and
contains only sensor nodes with temperature sensors for which evaluation of
the property \emph{isActive} returns \emph{true}. The data view definitions are
used to restrict  the scope of the DADT operations.

\subsection{Limitations of the DADT Prototype}

The DADT prototype, proposed in \cite{migliavacca_DADT:2006}, enables the use of
DADTs to facilitate distributed application programming.

It supports is a Java-based application development and consists of two parts:
\begin{itemize}
  \item \emph{Translator}, that proviides translation of Java program
  extended with DADT programming constructs into conventional Java classes.
  \item \emph{Run-time library} is used at translation step and allows to run
  created Java classes in  JVM.
\end{itemize}

Run-time library provides support for DADT constructions and methods, such as
\emph{binding} ADTs to DADTs, \emph{DADT Views}, \emph{Actions} and
\emph{Operators}. 

The communication in the prototype is based on the IP Multicast principle, and
allows to deliver information to the ADTs bound to a specific DADT, defined as
a multicast group.

The DADT prototype has presented a proof of the DADT concept. While this
approach is clearly applicable to WSNs, the prototype itself did not support WSN
abstractions, and besides has major limitations to it:

\begin{itemize}
  \item The lack of a routing mechanism.
  \item Limitations in portability to real WSN nodes.
\end{itemize}

\section{The DADT/LN Prototype}

\subsection{Motivation}

The DADT prototype proposed in \cite{migliavacca_DADT:2006} showed that the
concept of DADTs can be possibly used for distributed WSN
applications, but existing limitations prevent its use in WSN simulators or real nodes.

This work makes the following contributions:

\begin{itemize}
  \item Enhance the DADT prototype for use in WSNs by extending it to run
  on simulators as well as devices in a real-world environment.
  \item Interfacing the LN mechanism presented in \cite{mottola_LNAbstraction}
  to enable abstracted communication between groups of nodes in the WSN defined
  by DADTs.
  \item  Provides verification of the utility of DADT abstractions in the WSN
  application layer.
\end{itemize}

\subsection{Overview}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/DADTLN_workflow.eps} 
\caption[DADT/LN application workflow]{Workflow for development of an application that uses
the DADT/LN prototype}
\label{Fig:DADTLN_workflow}
\end{figure} 
The overview of the workflow involved in using DADTs to enable WSN application
programming is shown in Figure \ref{Fig:DADTLN_workflow}. The application
developer provides an application layer code for the WSN using a DADT
language in a series of \emph{.dadt} files (see Section
\ref{subsec:DADTlanguage} for further details). A preprocessor is used to
convert the code written by the application programmer into Java code that interfaces with the DADT infrastructure (extended from the prototype presented in
\cite{migliavacca_DADT:2006}). In order to facilitate routing to LNs defined by DADT Views, the DADT infrastructure is interfaced with the a
previously developed implementation of LNs. 

The application (including the implementation of layers lower in the protocol
stack) is then loaded on to either:
\begin{itemize}
\item the JiST/SWANS simulator \cite{barr_JIST:2005, barr_SWANS} (Section
\ref{sec:jistswans} provides implementation details of the simulator) 
\item a collection of Sun SPOT wireless sensor devices
\cite{simon_squawk:2006} (see Section \ref{sec:sunspots}) to execute the given 
application on real sensor nodes.
\end{itemize}

\begin{figure}
\centering
\includegraphics[scale=0.55]{img/DADTLN_glossary.eps} 
\caption[WSN in DADT/LN prototype]{Schematic representation of the WSN as
abstracted in the DADT/LN prototype}
\label{Fig:DADTLN_glossary}
\end{figure} 

The WSN network in the DADT/LN prototype developed as part of
this work consists of two types of devices as shown in Figure
\ref{Fig:DADTLN_glossary}:
\begin{itemize}
  \item \emph{Controller}
  \item \emph{Sensor Device}
\end{itemize}  
   
\emph{Controller} is typically resided on PC. On the application layer this
abstraction includes the distributed application code, the DADT
instance, the DADT manager. Network layer entity con the LN implementation is
used in the network layer.
  
\emph{Sensor Device} is a ``hardware" sensor device such as a Sun SPOT, 
which holds the entities of application Layer, which includes a Sensor Node
abstraction consisting of multiple sensor ADT instances, and an ADT
manager, and a network layer entity which is represented by the LN implementation.

\subsection{Architecture}

The architecture of the DADT/LN prototype presented in the Figure
\ref{Fig:DADTLN_architecture} and contains a few logical layers.

\begin{figure}
\centering
\includegraphics[scale=0.65]{img/DADTLN_architecture.eps} 
\caption[DADT/LN architecture]{Architecture of the DADT/LN prototype}
\label{Fig:DADTLN_architecture}
\end{figure} 

Upper layer presents distributed application code implemented by an application
developer. It is written in the DADT specification language (see Section
\ref{subsec:DADTlanguage}) and later is translated into executable Java code,
which uses the DADT runtime resided in the next layer as API.

The layer below holds DADT runtime library which provides handling of ADTs and
DADTs. In particular, the class \emph{DADTMgr} manages binding and unbinding of
ADT instances into DADT type, provides support for space ADTs through the
\emph{Site} class, and handles other relevant aspects. 
The abstract classes \emph{Property} and \emph{Action} represent the
corresponding concepts, described in the Section \ref{subsec:DADTsConcepts}.
The class \emph{View} provides support for data and space DADT Views, and
contains the set of \emph{Property} objects, that define the scope of the
operations. Properties are organised into an abstract tree which provides the
logical predicate defining the view, with the leaves representing DADT
properties and the nodes specifying boolean operators used to compose it.

\textcolor{green}{to be expanded a bit more, 13/08}

The lower layer provides support for interfacing DADT runtime and LN runtime.
This is achived by using instances of the \emph{LNNodeManager} on each sensor
device and \emph{LNDistrNodeManager} instance on the controller node. 

Communication between sensor devices and controller node is handled by LN
runtime layer and from the application's view achieved by use of 
\emph{RequestMsg} and \emph{ReplyMsg} messages.



\subsection{DADT specification language} \label{subsec:DADTlanguage}
 
%FILL THIS

\subsection{Implementation Details}

This section attempts to explain the operation of the DADT/LN prototype
developed as part of this work by considering the sequence of method calls made
during execution. The operation of the simulation platform as well as the
nodes itself is abstracted from the explanations that follow, as is the actual
\emph{.dadt} syntax used by the application programmer himself to trigger these
operations. 

\subsubsection{The DADT/LN prototype on the Controller}

Figure \ref{Fig:SeqDiagram_PCnode} presents the operation of the DADT/LN
prototype on the controller (which is typically PC-based). As shown in the figure, the implementation running on each sensor node 
consists of the following entities:

\begin{itemize}
  \item \emph{Client Node}
  \item \emph{DADT Instance}
  \item \emph{Expression Tree} 
  \item \emph{DADT Manager} 
  \item \emph{Data View} 
\end{itemize}

A \emph{Client Node} is an abstraction that holds a DADT
instance. The application programmer's requests to the network are issued
by the Client Node.
  
A \emph{DADT Instance} allows for collective access to multiple ADT instances,
as it was described in Section \ref{subsubsec:dadtspecandinst}.

An \emph{Expression Tree} is a specific construct that allows to build a
hierarchical data view.

A \emph{DADT Manager} provides the interface between the Client Node and the
network, and passes request messages from the Client Node to the lower layers
of the protocol stack.

\emph{Data Views} present a mechanism for partitioning the collection of
ADT instances bound to a particular DADT type, and were explained in Section
\ref{subsubsec:views}.

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{img/SeqDiagram_PCnode.eps}
\caption[Operation of the DADT/LN prototype on Controller]{Operation of the DADT/LN prototype on Controller}
\label{Fig:SeqDiagram_PCnode}
\end{sidewaysfigure}

The instantiation of a DADT type by the application programmer's
code\footnote{This is written in the DADT specification language.} causes the
following actions to take place at the Controller:
\begin{itemize}
 \item the Client Node creates an instance of the DADT type that is used to
  perform collective operations on the network.   
  \item a new expression tree
  is created to provide a hierarchical representation of the application programmer's definition of a data view.
  \item the DADT instance creates an instance of the DADT Manager.
\end{itemize}

When the application programmer's code requests the execution of a distributed operation
on the WSN, the Client Node forwards the request to the DADT instance, which
processes the request and communicates with an underlying WSN.

The DADT instance performs following actions:
  \begin{itemize} 
    \item it processes the request and according to the defined scope of the
    distributed operation constructs the relevant DADT View using the
    expression tree object,
    \item subsequently uses the DADT Manager to specify LN for the
    provided request, by using a special procedure of mapping DADT properties
    from the expression tree object into LN predicates,
    \item using the DADT manager it constructs and sends a request message to
    underlying WSN, and
    \item being a separate thread, it sleeps until, if required, the result of
    the request is received from the network layer.
  \end{itemize}
  
If no reply from the WSN nodes is expected the Client Node continues its work in
the normal mode. This situation may happen if the request was presented by an
action such as \emph{Reset} sensors. 
 
On the other hand, if the result of the distributed computation is exp ected and
finally received, the Client Node is notified. The Client Node then executes the
appropriate function on the DADT instance to collect and process the readings.
The DADT instance returns the processed readings to the Client Node.

\subsubsection{The DADT/LN prototype on the sensor device} \label{subsubsec:DADTLNSensorDevice}

Figure \ref{Fig:SeqDiagram_Sensornode} presents the operation of the DADT/LN
prototype on the sensor device (which may be either simulated or a real
device). As shown in the figure, the implementation running on each sensor node 
consists of the following entities:

\begin{itemize}
  \item \emph{Sensor Node} 
  \item \emph{Sensor ADT instance} 
  \item \emph{ADT Manager} 
\end{itemize}

A\emph{Sensor Node} is an abstraction that consists of a list of sensors. This
follows from the example used to illustrate the concept of ADTs in Section
\ref{subsec:ADTSpecInst}. The term \emph{sensor device} is used to refer to the
physical sensor node entity, while the term \emph{sensor node} refers to the application
layer abstraction of all of the sensors within the device. This abstraction
resides on the device.

A \emph{Sensor ADT instance} is an ADT instance for a given sensor on the sensor
node upon which the prototype executes.

An \emph{ADT Manager} provides the interface between the sensor node and the
network, thereby abstracting sensor ADT instances from queries issued by the DADT
instance at the (PC-based) controller.

\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{img/SeqDiagram_Sensornode.eps}
\caption[Operation of the DADT/LN prototype on sensor device]{Operation of the DADT/LN prototype on sensor device}
\label{Fig:SeqDiagram_Sensornode}
\end{sidewaysfigure}

Intialisation of the Sensor ADT instance is performed possibly
multiple times on a given Sensor Node, as a node might consist of multiple sesnsors. Following
this, the sensor ADT instances are bound to a particular DADT type by calling
the ADT manager\footnote{The ADT manager is assumed in our
current implementation to be aware of all DADT types defined in the WSN.}.

When the lower layer (which runs the LN algorithm) delivers a message to the
Sensor Node, the ADT Manager is used to processed the request message.The
request message contains a DADT Data view (see Section \ref{subsubsec:views})
which is used to filter from the sensor ADT instances on the given Sensor node
those that fit into the Data View. 

If the request message is received in the application layer, then at least one of
the sensor ADT instances in the Sensor Node fits into the dataview, as the data
view is expressed in the form of an LN predicate. This minimises the number of
messages received at the application layer. However, since a given Sensor Node
may contain several sensor ADT instances, the ADT instances have to be filtered.

The request message also contains a description of the DADT action to be
performed on-device (see Section
\ref{subsubsec:OperatorsAndActions}). The ADT manager calls the action for each
sensor ADT instance that fits into the DADT Data View. 

If the application layer requires that a reply be sent, the LN implementation in
the lower layer of the protocol stack is used as it can be seen on the bottom
right section of Figure \ref{Fig:SeqDiagram_sensornode}.



\subsection{The DADT/LN prototype in the simulated environment}
\subsubsection {JiST/SWANS} \label{sec:jistswans}

As the simulator used in this work is a discrete event simulator, this section 
begins with a short description of discrete event simulators. 
This is followed by a discussion on a particular discrete event simulator
called JiST, and the SWANS network simulator built on top of JiST.

\paragraph{Discrete Event Simulator}

A discrete event simulator allows for the simulated execution of a process (that
may be either deterministic or stochastic), and consists of the following
components \cite{Shankar_DiscreteEventSim}:

\begin{itemize}
  \item \emph{Simulation variables:} These variables keep track of simulation 
  time, the list of events to be simulated, the (evolving) system state, and 
  performance indicators.
  \item \emph{Event handler:} The event handler schedules events for execution 
  at specific points in simulation time (and unschedules them if necessary), 
  and additionally updates the state variables and performance indicators.
\end{itemize}
 
\paragraph{Java In Simulation Time (JiST)} \label{subsec:jist}

JiST \cite{barr_JIST:2005} is a discrete event simulator that is 
efficient (compared to existing simulation systems), 
transparent (simulations are automatically translated to run with the 
simulation time semantics), and standard (simulations use a
conventional programming language, i.e., Java).

JiST simulation code is written in Java, and converted to run over the JiST 
simulation kernel using a bytecode-level rewriter\footnote{The bytecode 
rewriter and the simulation kernel are both written in Java},  as it can be
seen in Figure \ref{Fig:JiST_architecture}.

The execution of a JiST program can be understood by considering example as
shown in Listing \ref{listing:JiSTExample}

\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Example JiST program (reproduced from \cite{barr_JIST:2005}, label = listing:JiSTExample]  
import jist.runtime.JistAPI;  
class hello implements JistAPI.Entity { 
  public static void main(String[] args) { 
    System.out.println("Simulation start"); 
    hello h = new hello(); 
    h.myEvent(); 
  } 
  public void myEvent() { 
    JistAPI.sleep(1); 
    myEvent(); 
    System.out.println("hello world, " + JistAPI.getTime()); 
  }} 
\end{lstlisting}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/JiST_architecture.eps} 
\caption[The JiST System Architecture]{The JiST system architecture (reproduced from
\cite{barr_JIST:2005})}
\label{Fig:JiST_architecture}
\end{figure}  
 
This program is then compiled and executed in the JiST simulation
kernel, using the following commands:

  
\begin{lstlisting}[frame=trbl, basewidth={0.55em, 0.6em}, captionpos=b, 
basicstyle=\ttfamily\footnotesize, breaklines, caption = Execution of the
program in the JiST, label = listing:JiST ]  
javac hello.java
java jist.runtime.Main hello
\end{lstlisting}


The simulation kernel is loaded upon execution of this command. This kernel
installs into the JVM a class loader that performs the rewrite of the bytecode.
The JistAPI functions used in the example code are used to perform the
code transformations. The method call to myEvent is now scheduled and executed
by the simulator in simulation time. Simulation time differs from ``actual''
time in that the advancement of actual time is independent of application
execution. 
 
\paragraph{Scalable Wireless Ad hoc Network Simulator (SWANS)}
SWANS is a wireless network simulator developed in order to provide efficient
and scalable simulations without compromising on simulation detail \cite{barr_SWANS},
and is built upon the JiST discrete event simulator described in Section \ref{subsec:jist}. 
It is organised a a collection of independent, relatively simple, event driven
components that are encapsulated as JiST entities. 

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/SWANS_architecture.eps} 
\caption[SWANS architecture]{SWANS architecture}
\label{Fig:SWANS_architecture}
\end{figure} 
  
SWANS has the following capabilities \cite{barr_SWANS}:

\begin{itemize}
\item The use of
interchangeable components enables the construction of a protocol stack for the
network, and facilitates parallelism, and execution in a distributed environment.
\item Can execute unmodified Java network applications on the
simulated network (in simulation time), by virtue of its being built over
JiST.Using a harness, the aforementioned Java code is automatically rewritten to
run on the simulated network.  
\end{itemize}
   
The SWANS architecture may be seen in Figure \ref{Fig:SWANS_architecture}. 


\subsubsection{Simulation using JiST/SWANS}

The DADT/LN prototype was tested on the SWANS WSN simulator, that is built upon
the JiST discrete event simulator (see Section \ref{subsec:jist}). 

The DADT/LN prototype code is wrapped in the JiST API, and is loaded on to a
simulated node. As described in the previous section, there are two kinds of
nodes in the DADT/LN prototype:

\begin{itemize}
  \item \emph{Controller Node}, that holds the distributed application, and the
  framework to manage the same.
  \item \emph{Sensor Device}, that holds the individual ADT instances. 
\end{itemize}

The Controller Node was implemented as a separate node on the JiST/SWANS
simulator, and was run as an undependet WSN simulated node for the purposes of
simulation. The Sensor Device implementation (see Section
\ref{subsubsec:DADTLNSensorDevice}) was loaded on to all but one of the nodes in
the simulator.

The simulation was run on networks of upto 50 nodes to empirically verify the
robustness of the work done as part of this thesis.

\subsection{The DADT/LN prototype on Sun SPOTs}

For further experimental validation of the implementation produced as part of 
this thesis,
the DADT/LN prototype was deployed on Sun SPOTs \cite{simon_squawk:2006}. 

The
Controller application was executed as a host application on the host machine (a
PC), while the other Sun SPOTs ran the Sensor Device implementation as on-SPOT
applications (see Section \ref{subsec:sunspotapps} for a description of host and on-SPOT
applications).

\section{Evaluation}

The performance of the DADT/LN prototype was evaluated using the following
metrics: 
\begin{itemize}
  \item Packet processing workload on the application layer.
  \item Ease of implementation. 
\end{itemize}

The first metric was used to compare the performance of the DADT/LN prototype
against that of the original DADT prototype used as the basis for this work
\cite{migliavacca_DADT:2006}. In the original DADT prototype, a request message
was replied to or discarded on the basis of an expression tree evaluation in the
application layer. In the implementation presented in this work, the integration
with the LN approach results in unsuitable request messages being discarded on
the basis of predicate evaluation in the network layer. 

A series of simulations were run using the JiST/SWANS simulations to determine
the number of request messages discarded at the network layer and the number
passed on to the application layer by the LN predicate matching algorithm. The
sum provides the total number of packets processed in the application layer of
the original DADT prototype.

It was found that the number of messages processed in the application layer was
lower in the implementation produced as part of this work.

%HOW CAN WE SAY LN PREDICATE EVAL IS MORE EFFICIENT THAN EXPRESSION TREE?

%
%The second metric used the number of lines of code required to implement a
%simple distributed averaging application. While not an ideal metric, it
%quantifies the difference in the order of magnitude of coding effort required
%on the part of the application programmer to produce WSN applications with and
%without the use of programming abstractions. To this end, a simple WSN
%application was written on the Sun SPOTs to calculate the distributed average.

%The difference in the number of lines was **.

\section{Future Work}

This section presents a list of possible extensions to the work implemented as
part of this thesis. These include:

\begin{itemize}
  \item \emph{Support for DADT selection operators:} The current prototype
  supports the selection of all ADT instances that match a defined DADT Data
  view, but does not enable the selection of a subset of the aforementioned
  collection of ADT instances. This arises due to limitations in the current LN implementation.
  \item \emph{Extending support for Space DADTs:} Currently, the prototype
  provide a limited support for the notion of space. Therefore, a
  possible avenue for future work could include the extended support implementation of Space DADTs.
  \item \emph{Extending the prototype for networks of heterogenous nodes:}
  The current prototype, by virtue of it being implemented in Java, cannot be
  used on a wide variety of different nodes. 
\end{itemize}

\section{Conclusions}

%HERE MORE BLAH BLAH